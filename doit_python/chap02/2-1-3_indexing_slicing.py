x = [11,22,33,44,55,66,77]

x[2] # 33
x[-4] = 3.14 # 11,22,33,3.14,55,66,77

s = [11,22,33,44,55,66,77]

s[0:6] # 11,22,33,44,55,66
s[0:7] # 11,22,33,44,55,66,77
s[0:7:2] # 11,33,55,77
s[-4:-2] # 44,55 <뒤에서 4번째 ~ 뒤에서 2번쨰
s[3:1] # x

'''
s[i:j:k] -> i,j >len(s) == len(s)
i가 없거나 none = 0
j가 없거나 none = 0
'''

s[:] # 11,22,33,44,55,66,77
s[:3] # 11,22,33
s[3:] # 55,66,77
s[-3:] # 55,66,77
s[::2] # 11,33,55,77 > 맨 앞에서부터 2개씩 건너 뛰면서 출력
s[::-1] # 77,66,55,44,33,22,11 > 거꾸로 출력

n = 5
id(n) 
n = 'ABC'
id(n)

'''
n이 5일 때의 id != 'ABC'일 때의 id -> 식별 번호가 뒤바뀐다.(값이 바뀌는 게 아님!)
'''

n += 1
id(n)
id(6)
'''
누적 변수 n을 1만큼 증가시키면 n의 식별 번호가 바뀜.
n이 참조하는 곳이 5에서 6으로 뒤바뀌는 것. 5라는 메모리 주소를 참조
immutable 객체의 값이 같은 경우에 변수에 상관없이 동일한 곳을 참조
정수를 나타내는 int, 문자열을 나타내는 str = 값 변경 불가. -> immutable
문자열 객체가 메모리의 4399272816 번지에 할당되고 해당 객체를 n이라는 변수가 바인딩함.
int형 정수형 객체 5의 값 자체를 바꾸는 것이 불가능 -> 다른 정수형 객체 6을 참조하도록 업데이트
'''

a = 1
before_plus = id(a)
a += 1
after_plus = id(a)
 
print(before_plus, after_plus)
# 1887852167408 1887852167440
print(before_plus == after_plus)
# False
 
# 1을 더했을 때 메모리 주소가 바뀐 모습을 볼 수 있다.

'''
before_plus에는 a에 1을 더하기 전 메모리 주소를 담았고, after_plus에는 a에 1을 더한 후 메모리 주소를 담았다. 
그 결과 메모리 주소가 달라진 것을 확인할 수 있다.
파이썬 사용자들이 가지는 대표적인 오개념 중 하나이다. 
a가 가리키는 메모리 안의 값이 1에서 2로 바뀐 것이 아닌, 정수 1을 담고 있는 객체를 가리키는 주소에서 정수 2를 담고 있는 객체로 a의 주소가 바뀐 것이다. 
다른 말로, '=' 연산자는 할당 연산자의 개념에 더 가깝지, 데이터를 변화시키는 개념이 아니다.
이유는 간단하다. 정수형(int)은 불변 객체이기 때문이다.
메모리에 담긴 데이터(1)는 무슨 일이 있어도 바뀌지 않기 때문에, 
'정수 2'라는 값을 나타내 주기 위해선 새로운 공간에 데이터(2)를 할당해주어야 하기 때문이다.
따라서 새로운 메모리 주소를 a와 연결 지었고, 따라서 메모리 주소를 반환하는 id 함수의 반환 값이 달라지는 것이다.
'''

# 1에서 2로 바로 값을 수정한 것이 아님(주소가 다르니)
# 1이라는 객체는 그대로! 2라는 객체를 새로 생성!(그러니 메모리 주소가 다르지)
# immutable -> 수정 불가능! 객체 할당하면 주소 안 바뀜! 걔는 영원히 걔임. 무조건 새로운 객체 할당!
# mutable -> 수정 가능! [1,2] -> [1,2,3] 같은 주소에서 바꾸는 것도 가능! 
# https://0xffffffff.tistory.com/75